{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, getCurrentInstance, h } from 'vue';\nimport { markRaw, toRaw } from '@vue/reactivity';\nimport { ComponentUtil, Grid } from 'ag-grid-community';\nimport { VueFrameworkComponentWrapper } from './VueFrameworkComponentWrapper';\nimport { getAgGridProperties } from './Utils';\nimport { VueFrameworkOverrides } from './VueFrameworkOverrides';\nconst ROW_DATA_EVENTS = ['rowDataChanged', 'rowDataUpdated', 'cellValueChanged', 'rowValueChanged'];\nconst DATA_MODEL_ATTR_NAME = 'onUpdate:modelValue'; // emit name would be update:ModelValue\nconst DATA_MODEL_EMIT_NAME = 'update:modelValue';\nconst [props, watch] = getAgGridProperties();\nexport const AgGridVue = defineComponent({\n  render() {\n    return h('div');\n  },\n  props: Object.assign({\n    gridOptions: {\n      type: Object,\n      default: () => ({})\n    },\n    autoParamsRefresh: {\n      type: Boolean,\n      default: () => false\n    },\n    componentDependencies: {\n      type: Array,\n      default: () => []\n    },\n    plugins: [],\n    modules: {\n      type: Array,\n      default: () => []\n    },\n    modelValue: {\n      type: Array,\n      default: undefined,\n      required: false\n    }\n  }, props),\n  data() {\n    return {\n      gridCreated: false,\n      isDestroyed: false,\n      gridReadyFired: false,\n      emitRowModel: undefined\n    };\n  },\n  watch: Object.assign({\n    modelValue: {\n      handler(currentValue, previousValue) {\n        this.processChanges('rowData', currentValue, previousValue);\n      },\n      deep: true\n    }\n  }, watch),\n  methods: {\n    globalEventListener(eventType, event) {\n      if (this.isDestroyed) {\n        return;\n      }\n      if (eventType === 'gridReady') {\n        this.gridReadyFired = true;\n      }\n      this.updateModelIfUsed(eventType);\n    },\n    processChanges(propertyName, currentValue, previousValue) {\n      if (this.gridCreated) {\n        if (this.skipChange(propertyName, currentValue, previousValue)) {\n          return;\n        }\n        const changes = {};\n        changes[propertyName] = {\n          // decouple the row data - if we don't when the grid changes row data directly that'll trigger this component to react to rowData changes,\n          // which can reset grid state (ie row selection)\n          currentValue: propertyName === 'rowData' ? Object.isFrozen(currentValue) ? currentValue : markRaw(toRaw(currentValue)) : currentValue,\n          previousValue\n        };\n        ComponentUtil.processOnChange(changes, this.gridOptions.api);\n      }\n    },\n    checkForBindingConflicts() {\n      const thisAsAny = this;\n      if ((thisAsAny.rowData || this.gridOptions.rowData) && thisAsAny.modelValue) {\n        console.warn('AG Grid: Using both rowData and v-model. rowData will be ignored.');\n      }\n    },\n    getRowData() {\n      const rowData = [];\n      this.gridOptions.api.forEachNode(rowNode => {\n        rowData.push(rowNode.data);\n      });\n      return rowData;\n    },\n    updateModelIfUsed(eventType) {\n      if (this.gridReadyFired && this.$attrs[DATA_MODEL_ATTR_NAME] && ROW_DATA_EVENTS.indexOf(eventType) !== -1) {\n        if (this.emitRowModel) {\n          this.emitRowModel();\n        }\n      }\n    },\n    getRowDataBasedOnBindings() {\n      const thisAsAny = this;\n      const rowData = thisAsAny.modelValue;\n      return rowData ? rowData : thisAsAny.rowData ? thisAsAny.rowData : thisAsAny.gridOptions.rowData;\n    },\n    getProvides() {\n      let instance = getCurrentInstance();\n      let provides = {};\n      while (instance) {\n        if (instance && instance.provides) {\n          provides = Object.assign(Object.assign({}, provides), instance.provides);\n        }\n        instance = instance.parent;\n      }\n      return provides;\n    },\n    /*\n    * Prevents an infinite loop when using v-model for the rowData\n    */\n    skipChange(propertyName, currentValue, previousValue) {\n      if (this.gridReadyFired && propertyName === 'rowData' && this.$attrs[DATA_MODEL_ATTR_NAME]) {\n        if (currentValue === previousValue) {\n          return true;\n        }\n        if (currentValue && previousValue) {\n          const currentRowData = currentValue;\n          const previousRowData = previousValue;\n          if (currentRowData.length === previousRowData.length) {\n            for (let i = 0; i < currentRowData.length; i++) {\n              if (currentRowData[i] !== previousRowData[i]) {\n                return false;\n              }\n            }\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    debounce(func, delay) {\n      let timeout;\n      return () => {\n        const later = function () {\n          func();\n        };\n        window.clearTimeout(timeout);\n        timeout = window.setTimeout(later, delay);\n      };\n    }\n  },\n  mounted() {\n    // we debounce the model update to prevent a flood of updates in the event there are many individual\n    // cell/row updates\n    this.emitRowModel = this.debounce(() => {\n      this.$emit(DATA_MODEL_EMIT_NAME, Object.freeze(this.getRowData()));\n    }, 20);\n    const provides = this.getProvides();\n    const frameworkComponentWrapper = new VueFrameworkComponentWrapper(this, provides);\n    // the gridOptions we pass to the grid don't need to be reactive (and shouldn't be - it'll cause issues\n    // with mergeDeep for example\n    const gridOptions = markRaw(ComponentUtil.copyAttributesToGridOptions(toRaw(this.gridOptions), this, true));\n    this.checkForBindingConflicts();\n    const rowData = this.getRowDataBasedOnBindings();\n    gridOptions.rowData = rowData ? Object.isFrozen(rowData) ? rowData : markRaw(toRaw(rowData)) : rowData;\n    const gridParams = {\n      globalEventListener: this.globalEventListener.bind(this),\n      frameworkOverrides: new VueFrameworkOverrides(this),\n      providedBeanInstances: {\n        frameworkComponentWrapper\n      },\n      modules: this.modules\n    };\n    new Grid(this.$el, gridOptions, gridParams);\n    this.gridCreated = true;\n  },\n  unmounted() {\n    if (this.gridCreated) {\n      if (this.gridOptions.api) {\n        this.gridOptions.api.destroy();\n      }\n      this.isDestroyed = true;\n    }\n  }\n});","map":{"version":3,"names":["defineComponent","getCurrentInstance","h","markRaw","toRaw","ComponentUtil","Grid","VueFrameworkComponentWrapper","getAgGridProperties","VueFrameworkOverrides","ROW_DATA_EVENTS","DATA_MODEL_ATTR_NAME","DATA_MODEL_EMIT_NAME","props","watch","AgGridVue","render","Object","assign","gridOptions","type","default","autoParamsRefresh","Boolean","componentDependencies","Array","plugins","modules","modelValue","undefined","required","data","gridCreated","isDestroyed","gridReadyFired","emitRowModel","handler","currentValue","previousValue","processChanges","deep","methods","globalEventListener","eventType","event","updateModelIfUsed","propertyName","skipChange","changes","isFrozen","processOnChange","api","checkForBindingConflicts","thisAsAny","rowData","console","warn","getRowData","forEachNode","rowNode","push","$attrs","indexOf","getRowDataBasedOnBindings","getProvides","instance","provides","parent","currentRowData","previousRowData","length","i","debounce","func","delay","timeout","later","window","clearTimeout","setTimeout","mounted","$emit","freeze","frameworkComponentWrapper","copyAttributesToGridOptions","gridParams","bind","frameworkOverrides","providedBeanInstances","$el","unmounted","destroy"],"sources":["D:/Diploma/domains/eduload.vue/node_modules/ag-grid-vue3/lib/AgGridVue.js"],"sourcesContent":["import { defineComponent, getCurrentInstance, h } from 'vue';\nimport { markRaw, toRaw } from '@vue/reactivity';\nimport { ComponentUtil, Grid } from 'ag-grid-community';\nimport { VueFrameworkComponentWrapper } from './VueFrameworkComponentWrapper';\nimport { getAgGridProperties } from './Utils';\nimport { VueFrameworkOverrides } from './VueFrameworkOverrides';\nconst ROW_DATA_EVENTS = ['rowDataChanged', 'rowDataUpdated', 'cellValueChanged', 'rowValueChanged'];\nconst DATA_MODEL_ATTR_NAME = 'onUpdate:modelValue'; // emit name would be update:ModelValue\nconst DATA_MODEL_EMIT_NAME = 'update:modelValue';\nconst [props, watch] = getAgGridProperties();\nexport const AgGridVue = defineComponent({\n    render() {\n        return h('div');\n    },\n    props: Object.assign({ gridOptions: {\n            type: Object,\n            default: () => ({}),\n        }, autoParamsRefresh: {\n            type: Boolean,\n            default: () => false,\n        }, componentDependencies: {\n            type: Array,\n            default: () => [],\n        }, plugins: [], modules: {\n            type: Array,\n            default: () => [],\n        }, modelValue: {\n            type: Array,\n            default: undefined,\n            required: false\n        } }, props),\n    data() {\n        return {\n            gridCreated: false,\n            isDestroyed: false,\n            gridReadyFired: false,\n            emitRowModel: undefined\n        };\n    },\n    watch: Object.assign({ modelValue: {\n            handler(currentValue, previousValue) {\n                this.processChanges('rowData', currentValue, previousValue);\n            },\n            deep: true\n        } }, watch),\n    methods: {\n        globalEventListener(eventType, event) {\n            if (this.isDestroyed) {\n                return;\n            }\n            if (eventType === 'gridReady') {\n                this.gridReadyFired = true;\n            }\n            this.updateModelIfUsed(eventType);\n        },\n        processChanges(propertyName, currentValue, previousValue) {\n            if (this.gridCreated) {\n                if (this.skipChange(propertyName, currentValue, previousValue)) {\n                    return;\n                }\n                const changes = {};\n                changes[propertyName] = {\n                    // decouple the row data - if we don't when the grid changes row data directly that'll trigger this component to react to rowData changes,\n                    // which can reset grid state (ie row selection)\n                    currentValue: propertyName === 'rowData' ? (Object.isFrozen(currentValue) ? currentValue : markRaw(toRaw(currentValue))) : currentValue,\n                    previousValue,\n                };\n                ComponentUtil.processOnChange(changes, this.gridOptions.api);\n            }\n        },\n        checkForBindingConflicts() {\n            const thisAsAny = this;\n            if ((thisAsAny.rowData || this.gridOptions.rowData) &&\n                thisAsAny.modelValue) {\n                console.warn('AG Grid: Using both rowData and v-model. rowData will be ignored.');\n            }\n        },\n        getRowData() {\n            const rowData = [];\n            this.gridOptions.api.forEachNode((rowNode) => {\n                rowData.push(rowNode.data);\n            });\n            return rowData;\n        },\n        updateModelIfUsed(eventType) {\n            if (this.gridReadyFired &&\n                this.$attrs[DATA_MODEL_ATTR_NAME] &&\n                ROW_DATA_EVENTS.indexOf(eventType) !== -1) {\n                if (this.emitRowModel) {\n                    this.emitRowModel();\n                }\n            }\n        },\n        getRowDataBasedOnBindings() {\n            const thisAsAny = this;\n            const rowData = thisAsAny.modelValue;\n            return rowData ? rowData :\n                thisAsAny.rowData ? thisAsAny.rowData : thisAsAny.gridOptions.rowData;\n        },\n        getProvides() {\n            let instance = getCurrentInstance();\n            let provides = {};\n            while (instance) {\n                if (instance && instance.provides) {\n                    provides = Object.assign(Object.assign({}, provides), instance.provides);\n                }\n                instance = instance.parent;\n            }\n            return provides;\n        },\n        /*\n        * Prevents an infinite loop when using v-model for the rowData\n        */\n        skipChange(propertyName, currentValue, previousValue) {\n            if (this.gridReadyFired &&\n                propertyName === 'rowData' &&\n                this.$attrs[DATA_MODEL_ATTR_NAME]) {\n                if (currentValue === previousValue) {\n                    return true;\n                }\n                if (currentValue && previousValue) {\n                    const currentRowData = currentValue;\n                    const previousRowData = previousValue;\n                    if (currentRowData.length === previousRowData.length) {\n                        for (let i = 0; i < currentRowData.length; i++) {\n                            if (currentRowData[i] !== previousRowData[i]) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        debounce(func, delay) {\n            let timeout;\n            return () => {\n                const later = function () {\n                    func();\n                };\n                window.clearTimeout(timeout);\n                timeout = window.setTimeout(later, delay);\n            };\n        }\n    },\n    mounted() {\n        // we debounce the model update to prevent a flood of updates in the event there are many individual\n        // cell/row updates\n        this.emitRowModel = this.debounce(() => {\n            this.$emit(DATA_MODEL_EMIT_NAME, Object.freeze(this.getRowData()));\n        }, 20);\n        const provides = this.getProvides();\n        const frameworkComponentWrapper = new VueFrameworkComponentWrapper(this, provides);\n        // the gridOptions we pass to the grid don't need to be reactive (and shouldn't be - it'll cause issues\n        // with mergeDeep for example\n        const gridOptions = markRaw(ComponentUtil.copyAttributesToGridOptions(toRaw(this.gridOptions), this, true));\n        this.checkForBindingConflicts();\n        const rowData = this.getRowDataBasedOnBindings();\n        gridOptions.rowData = rowData ? (Object.isFrozen(rowData) ? rowData : markRaw(toRaw(rowData))) : rowData;\n        const gridParams = {\n            globalEventListener: this.globalEventListener.bind(this),\n            frameworkOverrides: new VueFrameworkOverrides(this),\n            providedBeanInstances: {\n                frameworkComponentWrapper,\n            },\n            modules: this.modules,\n        };\n        new Grid(this.$el, gridOptions, gridParams);\n        this.gridCreated = true;\n    },\n    unmounted() {\n        if (this.gridCreated) {\n            if (this.gridOptions.api) {\n                this.gridOptions.api.destroy();\n            }\n            this.isDestroyed = true;\n        }\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}